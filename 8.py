import math # импортируем модуль math для вычисления натурального логарифма.

def f(x): # определяем функцию `f`, которая возводит в квадрат натуральный логарифм
    return (math.log(5 * x) ** 2)

# далее функция будет вычислять интеграл функции `f` на интервале `[a, b]`
# с заданной точностью `eps`
def simpson_integral(a, b, eps):

    print("Каушанский Андрей")
    print("Вычисление интеграла методом Симпсона")
    print("Подинтегральное выражение:")
    print("ln^2(5*x)")
    print("Нижний предел интегрирования:", a)
    print("Верхний предел интегрирования:", b)
    print("Значение интеграла число разбиений")

    I = eps + 1 # I — предыдущее значение интеграла, инициализируем его значением, большим `eps`,
    # чтобы войти в цикл

    I1 = 0  # I1 — новое значение интеграла, инициализируем нулём

    N = 2

    # Начинаем цикл, который будет продолжаться, пока количество разбиений `N` не станет больше 4 или разность
    # между текущим и предыдущим значением интеграла больше `eps`
    while (N <= 4) or (abs(I1 - I) > eps):

        # Далее вычисляем шаг интегрирования `h`. Он равен длине отрезка `[a, b]`, делённому на количество
        # подотрезков (двойное количество разбиений `N`).
        h = (b - a) / (2 * N)

        # далее инициализируем переменные для суммирования значений функции на нечётных и чётных индексах.
        sum2 = 0  # Для чётных индексов
        sum4 = 0  # Для нечётных индексов

        # далее цикл перебирает нечётные индексы от 1 до 2*N. Для нечётных индексов мы добавляем значения
        # функции, умножая их на 4 (по формуле Симпсона). Для чётных индексов (в следующей итерации) мы
        # добавляем значения, умноженные на 2.
        for i in range(1, 2 * N, 2):
            sum4 += f(a + h * i)  # Значения с нечётными индексами, которые нужно умножить на 4.
            sum2 += f(a + h * (i + 1))  # Значения с чётными индексами, которые нужно умножить на 2.

        # далее считаем сумму для применения формулы Симпсона. Начинаем с значения функции `f(a)`
        # добавляем значения с чётными и нечётными индексами, и вычитаем значение `f(b)`
        # чтобы скорректировать двойное счёт.

        sum = f(a) + 4 * sum4 + 2 * sum2 - f(b)  # Отнимаем значение f(b), так как ранее прибавили его дважды.
        I = I1 # обновляем предыдущее значение `I` и вычисляем новое значение интеграла `I1` по формуле Симпсона.
        I1 = (h / 3) * sum

        print(f"{I1:10.5f} {N}") # выводим текущее значение интеграла `I1` и количество
        # разбиений `N` в удобочитаемом формате.
        N *= 2  # Увеличиваем число разбиений для лучшей точности

    return I1 # по завершении цикла функция возвращает значение интеграла

# далее определяем параметры: a- нижний предел, b-верхний предел, eps-точность.
a = 1.0
b = 100.0
eps = 0.0001

# Вызов функции для вычисления интеграла
simpson_integral(a, b, eps)