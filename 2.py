# Метод простых итераций
import math # импортируем встроенный модуль math, используемый для математических операций

# Определяем функцию
def f(z): # где z это переменная, которую мы будем подбирать. Подставляем ее вместо x в наше выражение
    return 2 * z - 0.5 - math.sin(z + 0.5) # значение, которое функция возвращает при вызове

# Определяем первую производную функции и используем ее для корректировки следующего значения
def f1(z):
    return 2 - math.cos(z + 0.5)

# Основная функция
def main():
    # Задаём интервал и точность вычислений
    a = 0 # a и b определяют интервал, в котором мы ищем корень (от 0 до 1).
    b = 1
    eps = 0.0001 # это заданная точность вычислений (0.0001)
    n = 1 # счетчик итераций, который начинается с 1

    # далее вывод начальной информации
    print("Каушанский Андрей")
    print("Функция sin(x + 0.5) = 2*x - 0.5") # наше выражение
    print("Интервал X c [{:.3f};{:.3f}]".format(a, b)) # обозначаем интервал X,
    # где 3f обозначает 3 числа после запятой


    print("Точность вычислений {:.4f}".format(eps)) # точность вычислений, где 4f-это числа после запятой
    print("Метод простых итераций")

    x = a # x инициализируется начальным значением `a`.
    lambda1 = 1 / f1(x) #  `lambda1` — это значение, которое используется для определения шага итерации,
    # оно считается как обратная величина производной в точке `x`.
    x_next = x - (lambda1) * f(x) # следующий x вычисляется по формуле итерации,
    # где мы применяем метод простых итераций.
    c = abs(x - x_next) # `c` — это разность между `x` и 'x' следующим, которая будет использована для
    # проверки сходимости. abc - используется для возвращения абсолютного значения числа

    print("{:.5f} {:.5f} {:.5f} {}".format(x, x_next, c, n))# здесь выводится текущее значение `x`,
    # новое значение `x_next`, разница `c` и номер итерации.

    while abs(x - x_next) >= eps and n < 2000: # Цикл продолжает выполняться, пока разница между
    # `x` и `x_next` больше или равна `eps` и количество итераций меньше 2000. Внутри цикла обновляются значения на
    # каждой итерации, и результат снова выводится на экран.
        x = x_next
        lambda1 = 1 / f1(x)
        x_next = x - (lambda1) * f(x)
        n += 1
        c = abs(x - x_next)

        print("{:.5f} {:.5f} {:.5f} {}".format(x, x_next, c, n))

    # далее выводится итоговое значение корня `x_next`, последнее значение `x`, и количество итераций, за которые
    # был найден корень.
    print("{:.5f} {:.5f} {}".format(x, x_next, n))
    print("Корень уравнения {:.5f} найден с точностью {:.4f} за {} итерации".format(x_next, eps, n))

# далее эта конструкция позволяет нам запускать функцию `main()` только тогда, когда файл запущен непосредственно,
# а не импортирован как модуль.
if __name__ == "__main__":
    main()